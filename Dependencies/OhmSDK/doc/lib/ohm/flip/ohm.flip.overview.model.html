<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Flip Overview: Interfacing with the Model</title>
<link rel="stylesheet" href="docpage.css" type="text/css" />
</head>

<script type="text/javascript">
function searchfield_focus(obj)
{
obj.style.color="#000"
if (obj.value=="Search Library")
	{obj.value=""}
}
</script>


<body>

<div id="header">
<div style="width: 1006px;">
<!--<form method="get" class="search" style="padding-top: 5px;"  action="http://www.google.com/search">
<input onfocus="searchfield_focus(this)" type="search" class="search" name="q" value="Search Library">
<input type="hidden" name="sitesearch" value="">
</form>-->
</div>
<p><a href="index.html">Ohm Force Developer Library</a><a href="ohm.flip.overview.about.html">Flip Overview</a></p>
</div>

<div id="toc">
<p>Flip Overview</p>
<ul>
<li><a href="ohm.flip.overview.about.html">About Flip</a></li>
<li><a href="ohm.flip.overview.how.html">How it Works</a></li>
<li><a href="ohm.flip.overview.model.html"><strong>Interfacing with the Model</strong></a>
	<ul>
	<li><a href="ohm.flip.overview.model.html#control">Controlling the Model</a></li>
	<li><a href="ohm.flip.overview.model.html#view">Observing the Model</a></li>
	</ul>
</li>
<li><a href="ohm.flip.overview.undo.html">Undo/Redo System</a></li>
<li><a href="ohm.flip.overview.threading.html">Threading System</a></li>
<li><a href="ohm.flip.overview.document.html">Document Format, Conversion</a></li>
</ul>

<div class="bottomspacer">&nbsp;</div>
</div>

<div id="content">

<div class="nav" align="right"><a href="ohm.flip.overview.how.html">previous</a><span>&nbsp;</span><a href="ohm.flip.overview.undo.html">next</a></div>

<h1>Interfacing with the Model</h1>

<p>When interfacing with the model, the code can be separated in two parts :</p>
<ol>
<li>the part that control the model
</li>
<li>the part that reacts to model changes
</li>
</ol>
<h2><a name="control">Controlling the Model</a></h2>
<p>Controlling the model is done by directly changing the model as you would
think with regular classes.</p>
<p>If a class
<span class="code">Element</span> 
has two members
<span class="code">_position</span> 
and
<span class="code">_length</span> 
,
changing the position and the length of the element is as simple as :</p>
<div class="codeblock">
<table>
<tr><td><pre>element._position = position;</pre></td></tr>
<tr><td><pre>element._length = length;</pre></td></tr>
</table>
</div>
<p>The members used in classes, are actually Flip classes object. They are proxies
that will handle the change to the model.</p>
<p>For example if you would write a class with a member :</p>
<div class="codeblock">
<table>
<tr><td><pre>int   _position;</pre></td></tr>
</table>
</div>
<p>You would transform it to :</p>
<div class="codeblock">
<table>
<tr><td><pre>flip::Int64 _position;</pre></td></tr>
</table>
</div>
<p>And if you would write a class with a member :</p>
<div class="codeblock">
<table>
<tr><td><pre>std::list &lt;Element&gt;  _element_arr;</pre></td></tr>
</table>
</div>
<p>You would transform it to :</p>
<div class="codeblock">
<table>
<tr><td><pre>flip::Array &lt;Element&gt;   _element_arr;</pre></td></tr>
</table>
</div>
<p>Manipulating the Flip containers is close to the standard library naming.
Adding an element is done through
<span class="code">insert</span> 
and erasing an element is done
through
<span class="code">erase</span> 
. Others functions are provided in a quite monolithic way
like in the original standard to ensure that client using already the
standard library will feel like just at home.</p>
<h2><a name="view">Observing the Model</a></h2>
<p>When a client modify its own model or receive a modification (transaction) of
the model from another client through the server, the model is directly modified.</p>
<p>The client of the model will have registered one or multiple observers to
observer how the model is modified.</p>
<p>The client observer is then called with the model root object as a parameter.</p>
<p>When the client observer is called, Flip maintains the previous version of
the model as well as the current one as applied by the transaction. This allows to
know :</p>
<ul>
<li>exactly which objects where modified
</li>
<li>the value of an object before of a modification
</li>
<li>what was inserted/erased from a container
</li>
<li>was was moved from a container to another
</li>
</ul>
<center><img src="ohm.flip.overview.model.png" /></center>
<p>The client is then responsible to parse the model tree to ensure that its local
representation of the model match the one from Flip.</p>
<p>Furthermore, Flip was designed to make this task as simple as possible :</p>
<ul>
<li>the model tree can be parsed in any direction, parsed multiple times, etc.
</li>
<li>one or multiple represented objects can be attached to Flip objects
</li>
<li>we made up a few pattern of code to simplify your work
</li>
</ul>
<p>As long as the model client does not exit from the observer call, Flip still
maintains the old and current version of the model. Each flip object as well
as your custom classes have an
<span class="code">is_invalid ()</span> 
member to know if
an object or its compound contains a modification, and this recursively.</p>
<p>Whenether your local model uses object pointers, references or ids, you can
attach it to any flip object. This also itself a best case interoperability
with your external libraries or your GUI in a very simple way.</p>


<div class="nav" align="right"><a href="ohm.flip.overview.how.html">previous</a><span>&nbsp;</span><a href="ohm.flip.overview.undo.html">next</a></div>

<div class="bottomspacer">&nbsp;</div>

</div>

<footer>
<a href="index.html">Ohm Force Developer Library</a> > <a href="ohm.flip.overview.about.html">Flip Overview</a> > <a href="ohm.flip.overview.model.html">Interfacing with the Model</a>
</footer>


</body>

</html>